---
name: cycle
description: Execute an iterative development cycle working on triaged tickets. Analyzes, implements, reviews, loops N times, then commits. Works only on approved tickets from tickets/ folder.
argument-hint: "[<task description>] --iterations <N>"
allowed-tools:
  - Task
  - Read
  - Write
  - Edit
  - Bash
  - Glob
  - Grep
  - TodoWrite
---

# Autonomous Worker: Development Cycle

You are executing an iterative development cycle. This cycle:
1. **ANALYZE** - Parallel agents examine the codebase and task
2. **IMPLEMENT** - Execute the task or work on triaged tickets
3. **REVIEW** - Parallel agents validate the implementation
4. **LOOP** - Repeat for the specified number of iterations
5. **COMMIT** - Auto-commit when all iterations complete (no push)

## Important: Ticket Generation is Separate

**Ticket generation is NOT part of this cycle.**

- Use `/aw:analyze-improve` to generate improvement tickets
- Use `/aw:analyze-features` to generate feature tickets
- Use `/aw:triage` to approve tickets for this cycle
- This cycle works on **already triaged tickets** from `tickets/`

## Arguments Parsing

Parse the user's input:
- `task_description`: Direct task OR "work tickets" to process ticket queue
- `iterations`: Number of cycles (default: 3)

Examples:
- `/aw:cycle "Add OAuth authentication" --iterations 4`
- `/aw:cycle --iterations 3` (works on triaged tickets)

## Pre-Cycle Setup

1. **Check for staging branch**: All work MUST branch from `staging`, never from `main`
2. **Create worktree** if doing parallel work:
   ```bash
   git worktree add ../aw-<task-slug> -b feature/aw-<task-slug> staging
   ```
3. **Read project context** from CLAUDE.md
4. **Check ticket queue**:
   ```
   .autonomous-worker/tickets/
   â”œâ”€â”€ P0-critical/    # Process first
   â”œâ”€â”€ P1-important/   # Process second
   â”œâ”€â”€ P2-improvement/ # Process if time
   â””â”€â”€ resolved/       # Completed
   ```

## Iteration Loop

For each iteration (1 to N):

### Phase 1: ANALYZE (Parallel Agents)

Launch these agents IN PARALLEL using Task tool with `run_in_background: true`:

1. **Structure Analyzer**: Examine architecture, file organization, dependencies
2. **Pattern Analyzer**: Find existing patterns, conventions, similar implementations
3. **Risk Analyzer**: Identify edge cases, potential issues with proposed changes

Wait for all agents to complete, then aggregate findings.

### Phase 2: IMPLEMENT

**If direct task (iteration 1)**:
- Implement the described task based on analysis

**If working tickets**:
- Read tickets from `tickets/P0-critical/` first
- Then `P1-important/`, then `P2-improvement/`
- Implement fixes for each

Use the `implementer` agent for complex implementations.

### Phase 3: REVIEW (Parallel Agents)

Launch these agents IN PARALLEL to **validate** the implementation:

1. **Security Reviewer**: Check for vulnerabilities
2. **Quality Reviewer**: Code quality, patterns, conventions
3. **Test Reviewer**: Test coverage, edge cases
4. **Performance Reviewer**: N+1 queries, bottlenecks

**Review generates validation feedback, NOT new tickets.**

If reviewers find issues:
- Minor issues: Fix immediately in this iteration
- Major issues: Log in cycle-log.md, handle in next iteration
- Critical blockers: Pause and report to user

### Phase 4: Iteration Summary

After review phase:
1. Log to `cycle-log.md`:
   ```markdown
   ## Iteration X/N
   - Analyzed: [summary]
   - Implemented: [changes made]
   - Reviewed: [validation results]
   - Issues Fixed: [count]
   - Status: [continuing/complete]
   ```
2. Mark resolved tickets (move to `resolved/`)
3. If more iterations remain, continue to next iteration
4. If final iteration, proceed to commit

## Final Commit

When all iterations complete:

1. Stage all changes: `git add -A`
2. Generate commit message:
   ```bash
   git commit -m "feat: <task summary>

   Changes:
   - <change 1>
   - <change 2>
   - <change 3>

   Tickets resolved: <list>
   Iterations: N

   ðŸ¤– Generated by autonomous-worker"
   ```
3. **DO NOT PUSH** - User will push when ready
4. Report completion with summary

## State Management

Maintain state in `.autonomous-worker/state.json`:
```json
{
  "current_task": "task description",
  "current_iteration": 1,
  "total_iterations": 3,
  "phase": "analyzing|implementing|reviewing|complete",
  "worktree_path": "../aw-task-slug",
  "branch": "feature/aw-task-slug",
  "started_at": "ISO timestamp",
  "tickets_resolved": []
}
```

## Review Validation (Not Ticket Generation)

The review phase validates quality but does **NOT** generate tickets:

### Security Reviewer Validates:
- No new vulnerabilities introduced
- Auth/authz properly implemented
- Input validation present
- No hardcoded secrets

### Quality Reviewer Validates:
- Code follows project conventions
- No obvious code smells
- Proper error handling
- Clear naming

### Test Reviewer Validates:
- New code has tests
- Existing tests still pass
- Edge cases covered

### Performance Reviewer Validates:
- No N+1 queries introduced
- Reasonable complexity
- No obvious bottlenecks

**If validation fails**: Fix in current/next iteration or report blocker.

## Important Rules

- NEVER push to remote - only commit locally
- ALL branches must originate from `staging`
- Work on TRIAGED tickets only (from `tickets/`)
- Review validates, does NOT generate new tickets
- Be autonomous but log everything
- Mark tickets as resolved when done
- Read CLAUDE.md context before starting
