---
name: cycle
description: Execute an iterative development cycle with parallel analysis, implementation, and review phases. Each iteration generates tickets for issues found, which are automatically addressed in subsequent iterations.
argument-hint: "<task description>" --iterations <N>
allowed-tools:
  - Task
  - Read
  - Write
  - Edit
  - Bash
  - Glob
  - Grep
  - TodoWrite
---

# Autonomous Worker: Development Cycle

You are executing an iterative development cycle for a task. This cycle consists of:
1. **ANALYZE** - Parallel agents examine the codebase
2. **IMPLEMENT** - Execute the task or fix tickets from previous iteration
3. **REVIEW** - Parallel agents review the implementation
4. **LOOP** - Repeat for the specified number of iterations
5. **COMMIT** - Auto-commit when all iterations complete (no push)

## Arguments Parsing

Parse the user's input to extract:
- `task_description`: The main task to accomplish
- `iterations`: Number of cycles (default: 3 if not specified)

Example: `/aw:cycle "Add OAuth authentication" --iterations 4`

## Pre-Cycle Setup

1. **Check for staging branch**: All work MUST branch from `staging`, never from `main`
2. **Create worktree** if doing parallel work:
   ```bash
   git worktree add ../aw-<task-slug> -b feature/aw-<task-slug> staging
   ```
3. **Read project context** from CLAUDE.md section `## Autonomous Worker Context` if it exists
4. **Initialize ticket directory**: `.autonomous-worker/tickets/` with structure:
   ```
   .autonomous-worker/
   â”œâ”€â”€ tickets/
   â”‚   â”œâ”€â”€ P0-critical/
   â”‚   â”œâ”€â”€ P1-important/
   â”‚   â””â”€â”€ P2-improvement/
   â”œâ”€â”€ state.json
   â””â”€â”€ cycle-log.md
   ```

## Iteration Loop

For each iteration (1 to N):

### Phase 1: ANALYZE (Parallel Agents)

Launch these agents IN PARALLEL using the Task tool with `run_in_background: true`:

1. **Structure Analyzer**: Examine architecture, file organization, dependencies
2. **Pattern Analyzer**: Find existing patterns, conventions, similar implementations
3. **Risk Analyzer**: Identify edge cases, potential bugs, security concerns

Wait for all agents to complete, then aggregate their findings.

### Phase 2: IMPLEMENT

Based on:
- Original task description (iteration 1)
- OR tickets from previous iteration (iteration 2+)

Execute implementation focusing on:
- P0 tickets first (blocking issues)
- P1 tickets second (important)
- P2 tickets if time permits

Use the `implementer` agent for complex implementations.

### Phase 3: REVIEW (Parallel Agents)

Launch these agents IN PARALLEL:

1. **Security Reviewer**: Check for vulnerabilities (OWASP, injection, auth issues)
2. **Quality Reviewer**: Code smells, DRY, SOLID, naming conventions
3. **Test Reviewer**: Test coverage, edge cases, missing tests
4. **Performance Reviewer**: N+1 queries, bottlenecks, memory leaks

Each reviewer generates tickets in the appropriate priority folder.

### Phase 4: Ticket Processing

After review phase:
1. Count tickets by priority
2. Log to `cycle-log.md`:
   ```markdown
   ## Iteration X/N
   - Analyzed: [summary]
   - Implemented: [changes]
   - Tickets Generated: P0: X, P1: Y, P2: Z
   - Status: [continuing/complete]
   ```
3. If more iterations remain, continue to next iteration
4. If final iteration, proceed to commit

## Final Commit

When all iterations complete:

1. Stage all changes: `git add -A`
2. Generate commit message summarizing:
   - Task accomplished
   - Key changes made
   - Tickets resolved
3. Commit with generated message:
   ```bash
   git commit -m "feat: <task summary>

   - <change 1>
   - <change 2>
   - <change 3>

   Resolved tickets: X P0, Y P1, Z P2
   Iterations: N

   ðŸ¤– Generated by autonomous-worker"
   ```
4. **DO NOT PUSH** - User will push when ready
5. Report completion with summary

## State Management

Maintain state in `.autonomous-worker/state.json`:
```json
{
  "current_task": "task description",
  "current_iteration": 1,
  "total_iterations": 3,
  "status": "analyzing|implementing|reviewing|complete",
  "worktree_path": "../aw-task-slug",
  "branch": "feature/aw-task-slug",
  "started_at": "ISO timestamp",
  "tickets": {
    "P0": 0,
    "P1": 0,
    "P2": 0
  }
}
```

## Important Rules

- NEVER push to remote - only commit locally
- ALL branches must originate from `staging`
- Generate tickets with full context and reproduction steps
- Prioritize P0 tickets - they block the cycle
- Be autonomous but log everything for transparency
- Read CLAUDE.md context before starting
